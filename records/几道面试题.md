---
title: 几道面试题
date: 2016-05-13 09:37:39
tags:
- 面试
categories: phper
---
记录一下面试遇到的几道题目。

#### php 传值赋值与引用赋值的区别 ####

>**传值赋值**：是把实参的值赋值给形参，那么对形参的修改，不会影响实参的值。

	<?php  
	$param1 = 1;                 
	$param2 = 2;                 
	$param2 = $param1;       
	echo $param2;         //显示为1  
	?>  
>**传引用**：真正的以地址的方式传递参数传递以后，形参和实参都是同一个对象，只是他们名字不同而已,对形参的修改将影响实参的值

	<?php
		$param1 = 1;
		$param2 = 2;
		$param2 = &$param1;
		echo $param2; //显示为1
		$param1 = 3;
		echo $param2;  //显示为3
	?>
***两者比较的话，传引用消耗的资源少。***

#### HTTP的常用几个状态码 ####

>200 ok 请求已成功，请求所希望的响应头或数据体将随此响应返回  
>304 Not Modified 如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码  
>403 Forbidden 服务器已经理解请求，但是拒绝执行它。  
>404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。  
>500 Internal Server Error 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般來說，這個問題都會在伺服器的程序碼出錯時出現。  
>503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。

#### 面向对象的多态性 ####
>多态性（polymorphisn）：是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

实现多态，有二种方式：覆盖，重载。
>**覆盖**：指子类重新定义父类的虚函数的做法。  
>**重载**：指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

那么，多态的作用是什么？
>多态的目的主要是为了实现接口重用。多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

#### 冒泡算法 ####
>冒泡排序（Bubble Sort）是一種簡單的排序算法。它重複地走訪過要排序的數列，一次比較兩個元素，如果他們的順序錯誤就把他們交換過來。走訪數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。

冒泡排序演算法的運作如下：

1. 比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。
2. 對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。
3. 針對所有的元素重複以上的步驟，除了最後一個。
4. 持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。

看代码：
	
    function swap(&$x, &$y) {
    	$t = $x;
    	$x = $y;
    	$y = $t;
    }
    
    function bubble_sort(&$arr) {//php的陣列視為基本型別，所以必須用傳參考才能修改原陣列
    	for ($i = 0; $i < count($arr) - 1; $i++)
    		for ($j = 0; $j < count($arr) - 1 - $i; $j++)
    			if ($arr[$j] > $arr[$j + 1])
    				swap($arr[$j], $arr[$j + 1]);
    }
    
    $arr = array(21, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70);
    bubble_sort($arr);
    for ($i = 0; $i < count($arr); $i++)
    	echo $arr[$i] . ' ';
#### 抽象类跟接口的区别 ####

抽象类：

> 抽象方法，只有行为的概念，没有具体的行为实现。使用：abstract 关键字修饰，并且没有方法体。  
> 包含抽象方法的类，就一定是抽象类。使用： abstract 关键字修饰，包含抽象方法。  
> 抽象类不能直接创建实例。可以定义引用变量。  
> 抽象类只能被继承，一个具体类继承一个抽象类，必须实现所有抽象方法。 

接口：

> 接口：全部的方法都是抽象方法，全部的属性都是常量。接口用来表示纯抽象概念，没有任何具体的方法和属性。  
> 不能实例化，可以定义变量。   
> 接口变量可以引用具体实现类的实例。   
> 接口只能被实现(继承)，一个具体类实现接口，必须使用全部的抽象方法。  
> 接口之间可以继承。  
> 一个具体类可以实现多个接口，实现多继承现象  
> 接口中的属性，默认是常量 public static final   
> 接中的方法一定是:public abstract   
> 实现一个接口，使用关键字implements, 实现实际上是一种继承关系。接口和实现类是父子类型的关系  